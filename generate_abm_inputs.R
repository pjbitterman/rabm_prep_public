### file created by @pjbitterman on 2016-07-13
### this script reads the attribute table output from my clu_farmer_numbers.mxd file
### 1) it cleans the input files
### 2) it then uses the lookup table created by @Haoyi to match CLU id to "new" HRU ids
### 3) it then preps the files for the ABM by ordering key variables
### 4) it then writes to disk
library(tidyverse)

#creates the files
createFiles <- function(numberOfiterations){

  if (numberOfiterations > 0){
    iterations <- seq(0, numberOfiterations - 1)
    for(it in iterations){
      createOneIteration(it)
    }
    
  } else {
    createOneIteration(0)
  }
    
}


createOneIteration <- function(currIter){
  
  #### PATHS ####
  #initial conditions for the abm/swat model
  in.cond.path <- "./output_to_abm/initialConditions/"
  #stochastic conditions for repeat runs of the abm - ALWAYS WRITE HERE
  sc.cond.path <- "./output_to_abm/stochasticConditions/"
  
  #### FILES ####
  #these generated by ArcMap
  f.wi  <- read.delim("./data/westIowa.txt", header = TRUE, sep = ",", stringsAsFactors = F)
  f.ic <- read.delim("./data/indianCreek.txt", header = TRUE, sep = ",", stringsAsFactors = F)
  f.cc  <- read.delim("./data/clearCreek.txt", header = TRUE, sep = ",", stringsAsFactors = F)
  
  #created by Haoyi and I
  lu.table <- read.csv("./data/clu_hru_lookupTable.csv", header = TRUE)
  
  #created by /github/diss_survey_analysis/ro1_cluster.r
  agent.profiles <- readRDS("./data/cluster_with_abm_vars.RDS")
  
  
  #### SCRIPT ###
  ##put in data frames
  w.iowa.raw <- tbl_df(data.frame(f.wi))
  ind.creek.raw <- tbl_df(data.frame(f.ic))
  cl.creek.raw <- tbl_df(data.frame(f.cc))
  
  
  arctables.cleaner <- function(intable){
    mydata <- intable
    mydata <- select(mydata, CALCACRES, PLANTID, PctRiseSlope, CropName, AreaKm2, haoyi_clu_id, 
                     TRACTNBR, CLUNBR, FARMNBR, FSA_ACRES, HELTYPECD, CLUCLSCD, HYDROGRP, xloc, yloc, CLU_ID,
                     Avg_CSR, Avg_CORNYLD, Avg_SOYBNYLD, Sum_isCRP)
    mydata <- mutate(mydata, uqOwnerId = paste0(TRACTNBR, CLUNBR, FARMNBR)) %>% 
      mutate(CLU_ID = ifelse(is.na(CLU_ID), 9999, CLU_ID)) %>%
      mutate(isCRP = ifelse(is.na(Sum_isCRP), FALSE, TRUE)) %>%
      select(-Sum_isCRP)
    mydata <- tbl_df(mydata)
    return(mydata)
  }
  
  w.iowa <- arctables.cleaner(w.iowa.raw)
  ind.creek <- arctables.cleaner(ind.creek.raw)
  cl.creek <- arctables.cleaner(cl.creek.raw)
  
  #count number of distinct clus by farmer
  cc.cluCounts <- cl.creek %>% distinct(FARMNBR, uqOwnerId) %>% count(FARMNBR)
  ic.cluCounts <- ind.creek %>% distinct(FARMNBR, uqOwnerId) %>% count(FARMNBR)
  wi.cluCounts <- w.iowa %>% distinct(FARMNBR, uqOwnerId) %>% count(FARMNBR)
  
  ###clu count by farmer follows power law distribution
  
  
  ###hydrogroup cleanup
  hydro.cleaner <- function(intable){
    hg <- intable$HYDROGRP
    hg <- as.character(hg)
    maj.table <- table(hg)
    maj.group <- names(maj.table[which.max(maj.table)])
    
    ###these are based off the more frequent pairwise types
    hg[hg == "A/B"] <- "B"
    hg[hg == "A/C"] <- "A"
    hg[hg == "A/D"] <- "A"
    hg[hg == "B/C"] <- "B"
    hg[hg == "B/D"] <- "B"
    hg[hg == "C/D"] <- "C"
    
    hg[hg == ""] <- maj.group
    hg[hg == " "] <- maj.group
    hg[hg == "  "] <- maj.group
    hg[hg == "   "] <- maj.group
    hg[hg == "."] <- maj.group
    hg[hg == "---"] <- maj.group
    
    mydata <- select(intable, -HYDROGRP)
    HYDROGRP <- as.factor(hg)
    mydata <- mutate(mydata, HYDROGRP)
    return(mydata)
  }
  
  wi.hclean <- hydro.cleaner(w.iowa)
  ic.hclean <- hydro.cleaner(ind.creek)
  cc.hclean <- hydro.cleaner(cl.creek)
  
  
  ###lookup table manipulation
  add.hru.and.sub <- function(intable){
    newSubID <- substr(lu.table$newHru, 2, 6)
    newHruID <- substr(lu.table$newHru, 7, length(lu.table$newHru))
    intable <- mutate(intable, newSubID, newHruID)
    intable <- select(intable, cluObjId, watershed, newSubID, newHruID)
    intable <- tbl_df(intable)
    return(intable)
  }
  lu.table.prep <- add.hru.and.sub(lu.table)
  
  
  ###join input to lookup table
  join.to.lu <- function(intable, lutable){
    ##use inner join to fit Haoyi's procedure
    joined <- dplyr::inner_join(intable, lutable, c("haoyi_clu_id" = "cluObjId"))
    
    return(joined)
  }
  ###join input to lookup
  wi.joined <- join.to.lu(wi.hclean, lu.table.prep)
  ic.joined <- join.to.lu(ic.hclean, lu.table.prep)
  cc.joined <- join.to.lu(cc.hclean, lu.table.prep)
  
  ###add crp as an initial land use
  wi.joined <- wi.joined %>% mutate(CropName = ifelse(isCRP, "crp", CropName))
  ic.joined <- ic.joined %>% mutate(CropName = ifelse(isCRP, "crp", CropName))
  cc.joined <- cc.joined %>% mutate(CropName = ifelse(isCRP, "crp", CropName))
  
  ###clean up cropNames to fit cropnames in lutypes.json 
  ###then generate new "two years ago land use types"
  
  cleanInitialLU <- function(landUse){
    toReturn <- landUse
    randLu <- c("corn", "soybeans")
    if(toReturn == "Agricultural Land-Generic"){
      toReturn <- randLu[sample(1:2, 1)]
    }
    if(toReturn == "Agricultural Land-Close-grown"){
      toReturn <- randLu[sample(1:2, 1)]
    }
    if(toReturn == "Alfalfa"){
      toReturn <- randLu[sample(1:2, 1)]
    }
    if(toReturn == "Oats"){
      toReturn <- randLu[sample(1:2, 1)]
    }
    if(toReturn == "Corn"){
      toReturn <- "corn"
    }
    if(toReturn == "Soybean"){
      toReturn <- "soybeans"
    }  
    if(toReturn == "Forest-Mixed"){
      toReturn <- "forest"
    }  
    if(toReturn == "Pasture"){
      toReturn <- "pasture"
    }  
    if(toReturn == "Range-Grasses"){
      toReturn <- "pasture"
    }
    
    return(toReturn)
  }
  
  setupPreviousLU <- function(initialLandUse){
    toReturn <- initialLandUse
    randLu <- c("corn", "soybeans")
    if(toReturn == "corn"){
      toReturn <- randLu[sample(1:2, 1)]
    }
    if(toReturn == "soybeans"){
      toReturn <- randLu[sample(1:2, 1)]
    }
    return(toReturn)
  }
  
  
  wi.initialLu <- sapply(wi.joined$CropName, function(x) cleanInitialLU(x))
  ic.initialLu <- sapply(ic.joined$CropName, function(x) cleanInitialLU(x))
  cc.initialLu <- sapply(cc.joined$CropName, function(x) cleanInitialLU(x))
  
  wi.previousLu <- sapply(wi.initialLu, function(x) setupPreviousLU(x))
  ic.previousLu <- sapply(ic.initialLu, function(x) setupPreviousLU(x))
  cc.previousLu <- sapply(cc.initialLu, function(x) setupPreviousLU(x))
  
  wi.joined <- select(wi.joined, -CropName)
  ic.joined <- select(ic.joined, -CropName)
  cc.joined <- select(cc.joined, -CropName)
  
  initialLu <- wi.initialLu
  twoPreviousLu <- wi.previousLu
  wi.luclean <- dplyr::mutate(wi.joined, initialLu, twoPreviousLu)
  
  initialLu <- ic.initialLu
  twoPreviousLu <- ic.previousLu
  ic.luclean <- dplyr::mutate(ic.joined, initialLu, twoPreviousLu)
  
  initialLu <- cc.initialLu
  twoPreviousLu <- cc.previousLu
  cc.luclean <- dplyr::mutate(cc.joined, initialLu, twoPreviousLu)
  
  ###re-allocate the parcels that did not match to existing farmers
  ###idToAllocate is the FARMNBR that represents those "missing" CLUs
  ###that didn't meet the join condition
  reallocateMissingFarmerNumbers <- function(inTable, idToAllocate){
    ##calculate the total number of acres in the watershed
    totalAcres <- sum(inTable$CALCACRES)
    idToAllocate = 0
    
    ##separate those farmers that have been asssigned from those that have not
    present <- filter(inTable, FARMNBR != idToAllocate)
    absent <- filter(inTable, FARMNBR == idToAllocate | is.na(FARMNBR))
    
    totalAcresPresent <- sum(present$CALCACRES)
    
    ##for those that have a proper farmer number, sum and sort (descending) them by acres
    present.summed <- present %>% group_by(FARMNBR) %>% select(FARMNBR, CALCACRES) %>% 
      summarise_each(funs(sum(CALCACRES)))
    present.sorted <- present.summed[order(-present.summed$CALCACRES),]
    
    present.proportion <- mutate(present.sorted, 
                                 prTotal = CALCACRES/totalAcresPresent, prPresent = CALCACRES/totalAcres)
    
    farmerList <- present.proportion$FARMNBR
    for(farmer in unique(farmerList)){
      targetProportion <- (filter(present.proportion, FARMNBR == farmer))$prTotal
      currentProportion <- (filter(present.proportion, FARMNBR == farmer))$prPresent
      
      while(currentProportion < targetProportion && nrow(absent) > 0){
        selectedParcel <- absent %>% sample_n(1)
        selectedParcel$FARMNBR <- as.numeric(farmer)
        selectedHruId <- selectedParcel$newHruID
        absent <- filter(absent, newHruID != selectedHruId)
        present <- bind_rows(present, selectedParcel)
        
        ##redo the proportions
        
        totalAcresPresent <- sum(present$CALCACRES)
        
        present.summed <- present %>% group_by(FARMNBR) %>% select(FARMNBR, CALCACRES) %>% 
          summarise_each(funs(sum(CALCACRES)))
        present.sorted <- present.summed[order(-present.summed$CALCACRES),]
        
        present.proportion <- mutate(present.sorted, 
                                     prTotal = CALCACRES/totalAcresPresent, prPresent = CALCACRES/totalAcres)
        currentProportion <- (filter(present.proportion, FARMNBR == farmer))$prPresent
        
      }
    }
    return(present)
  }
  
  cc.allocated <- reallocateMissingFarmerNumbers(cc.luclean, 0)
  wi.allocated <- reallocateMissingFarmerNumbers(wi.luclean, 0)
  ic.allocated <- reallocateMissingFarmerNumbers(ic.luclean, 0)
  
  ##fix the HEL (highly-erodable) designation
  fixHel <- function(inTable){
    toReturn <- inTable %>% mutate(HELTYPECD = ifelse(HELTYPECD == "Y", T, F))
    return(toReturn)
  }
  
  cc.helfix <- fixHel(cc.allocated)
  wi.helfix <- fixHel(wi.allocated)
  ic.helfix <- fixHel(ic.allocated)
  
  
  
  ###prep for agent params
  prep.for.abm <- function(intable){
    farmerId <- intable$FARMNBR
    ###sub-basin ID is always 1 if you're doing one sub-basin/watershed at a time
    subbasinId <- intable$newSubID
    hruId <- intable$newHruID
    acres <- intable$CALCACRES
    slope <- intable$PctRiseSlope
    hydrogroup <- intable$HYDROGRP
    lastLu <- intable$initialLu
    preLastLu <- intable$twoPreviousLu
    xloc <- intable$xloc
    yloc <- intable$yloc
    clu_id <- intable$CLU_ID
    csr <- intable$Avg_CSR
    cornYld <- intable$Avg_CORNYLD
    soybYld <- intable$Avg_SOYBNYLD
    hel <- intable$HELTYPECD
    isCrp <- intable$isCRP
    mydata <- tbl_df(data.frame(farmerId, subbasinId, hruId, acres, 
                                slope, hydrogroup, lastLu, preLastLu, 
                                xloc, yloc, clu_id, csr, cornYld, soybYld, hel, isCrp))
    
    ###adjust historic corn and soyb yields on FRST and PAST parcels
    toReturn <- mydata %>% mutate(cornYld = ifelse(lastLu == "FRST" | lastLu == "PAST", cornYld * .67, cornYld)) %>%
      mutate(soybYld = ifelse(lastLu == "FRST" | lastLu == "PAST", soybYld * .67, soybYld))
    
    return(toReturn)
    
  }
  
  wi.prepped <- prep.for.abm(wi.helfix)
  ic.prepped <- prep.for.abm(ic.helfix)
  cc.prepped <- prep.for.abm(cc.helfix)
  
  
  #### AGENT PARAMETERS ####
  
  
  generateAbmParameters <- function(watershedTable, agentTable){

    uq.agents <- unique(watershedTable$farmerId)
    n.uq.agents <- length(uq.agents)
    sampled <- sample_n(agentTable, n.uq.agents, replace = T)
    costOffset <- runif(n.uq.agents, 0, 40)
    names(sampled) <- c("per_freq30", "per_freq50", "clusterAssignment", "stopCondition", "propOwned")
    
    sampled <- sampled %>% mutate(per_freq30 = ifelse(per_freq30 == 0, 0, 
                                                     ifelse(per_freq30 == 1, 1, 
                                                            ifelse(per_freq30 == 2, 2,
                                                                   ifelse(per_freq30 == 3, 5,
                                                                          ifelse(per_freq30 == 4, 7, 
                                                                                 ifelse(per_freq30 == 5, 10, 10)))))))

    sampled <- sampled %>% mutate(per_freq50 = ifelse(per_freq50 == 0, 0, 
                                                     ifelse(per_freq50 == 1, 1, 
                                                            ifelse(per_freq50 == 2, 2,
                                                                   ifelse(per_freq50 == 3, 5,
                                                                          ifelse(per_freq50 == 4, 7, 
                                                                                 ifelse(per_freq50 == 5, 10, 10)))))))
    
    sampled <- sampled %>% mutate(stopCondition = ifelse(stopCondition == 0, 0, 
                                                     ifelse(stopCondition == 1, 1, 
                                                            ifelse(stopCondition == 2, 2,
                                                                   ifelse(stopCondition == 3, 5,
                                                                          ifelse(stopCondition == 4, 10, 10))))))
    
    
    toReturn <- data.frame(uq.agents, sampled, costOffset)
  }
  
  wi.agents <- generateAbmParameters(wi.prepped, agent.profiles)
  ic.agents <- generateAbmParameters(ic.prepped, agent.profiles)
  cc.agents <- generateAbmParameters(cc.prepped, agent.profiles)
  
  iterationPathToWrite <- paste0(sc.cond.path, currIter, "/")
  if(!dir.exists(iterationPathToWrite)){
    dir.create(iterationPathToWrite)
  }
  
  agentPathToWrite <- paste0(iterationPathToWrite, "agentInputTables/")
  if(!dir.exists(agentPathToWrite)){
    dir.create(agentPathToWrite)
  }
  
  write.csv(wi.agents, row.names = F, paste0(agentPathToWrite, "westIowa.csv"))
  write.csv(ic.agents, row.names = F, paste0(agentPathToWrite, "indianCreek.csv"))
  write.csv(cc.agents, row.names = F, paste0(agentPathToWrite, "clearCreek.csv"))
  
  
  #### CLU OWNERSHIP STATUS ####
  
  # assign a parcel to be owned or not according to a farmer's sampled proportion
  generateCluOwnership <- function(watershedTable, agentTable){
    
    farmerIds <- unique(agentTable$uq.agents)
    
    toReturn = data.frame()
    
    for(fid in farmerIds){
      farmer.parcels <- filter(watershedTable, farmerId == fid) %>% mutate(isOwned = FALSE)
      farmer.parcels.crops <- farmer.parcels %>% filter(lastLu == "corn" | lastLu == "soybeans")
      farmer.parcels.oop <- farmer.parcels %>% filter(lastLu == "forest" | lastLu == "pasture" | lastLu == "crp") %>% 
        mutate(isOwned = TRUE)
      
      production.acres <- sum(farmer.parcels.crops$acres)
      this_farmer <- agentTable %>% filter(uq.agents == fid)
      
      targetProportion <- this_farmer$propOwned
      currentProportion <- 0.0
      
      unownedParcels <- farmer.parcels.crops
      ownedParcels <- data.frame()
      
      while(currentProportion < targetProportion && nrow(unownedParcels) > 0){
        selectedParcel <- unownedParcels %>% sample_n(1)
        selectedParcel$isOwned <- TRUE
        selectedParcelHruId <- selectedParcel$hruId
        unownedParcels <- filter(unownedParcels, hruId != selectedParcelHruId)
        ownedParcels <- bind_rows(ownedParcels, selectedParcel)
        
        currentProportion <- sum(ownedParcels$acres) / production.acres
      }
      
      farmersParcels <- bind_rows(farmer.parcels.oop, unownedParcels, ownedParcels)
      toReturn <- bind_rows(toReturn, farmersParcels)
    }
    return(toReturn)
  }
  
  wi.final <- generateCluOwnership(wi.prepped, wi.agents)
  ic.final <- generateCluOwnership(ic.prepped, ic.agents)
  cc.final <- generateCluOwnership(cc.prepped, cc.agents)
  
  wsPathToWrite <- paste0(iterationPathToWrite, "watershedInputTables/")
  if(!dir.exists(wsPathToWrite)){
    dir.create(wsPathToWrite)
  }
  
  write.csv(wi.final, row.names = F, paste0(wsPathToWrite, "westIowa.csv"))
  write.csv(ic.final, row.names = F, paste0(wsPathToWrite, "indianCreek.csv"))
  write.csv(cc.final, row.names = F, paste0(wsPathToWrite, "clearCreek.csv"))
  
  print(paste0("iteration ", currIter, " has completed"))
}

